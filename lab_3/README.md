# Лабораторная работа 3

## Задание 1

Написать на C++ программу программу,
реализующую многопоточность на основе технологии OpenMP: она должна вычислять значение
функции с помощью редукции. Измерять время работы программ для различных значений
параметра N.

```
На основе двух равно размерных массивов A и B (длины N) функция возвращает произведение ненулевых значений Ai + Bi
```

## Задание 2

Модифицировать программу, составленную по **Заданию 1**, убрав возможность
параллельного использования вычислительных ресурсов. Измерять время работы программы для
тех же значений параметров, что были использованы при выполнении **Задания 1**.

## Как запустить

```
make; \
./bin/main 10
```

тут 10 - длина массивов (`N`)

## Результат работы

```
$ ./bin/main 100
N: 100; Paralled: 1; Product: 453600000; Elapsed time (ms): 0.1630
N: 100; Paralled: 0; Product: 453600000; Elapsed time (ms): 0.0031
```

```
$ ./bin/main 1000
N: 1000; Paralled: 1; Product:        0; Elapsed time (ms): 0.1592
N: 1000; Paralled: 0; Product:        0; Elapsed time (ms): 0.0047
```

```
$ ./bin/main 10000
N: 10000; Paralled: 1; Product:        0; Elapsed time (ms): 0.1786
N: 10000; Paralled: 0; Product:        0; Elapsed time (ms): 0.0363
```

```
$ ./bin/main 100000
N: 100000; Paralled: 1; Product:        0; Elapsed time (ms): 0.2350
N: 100000; Paralled: 0; Product:        0; Elapsed time (ms): 0.3434
```

```
$ ./bin/main 1000000
N: 1000000; Paralled: 1; Product:        0; Elapsed time (ms): 9.6324
N: 1000000; Paralled: 0; Product:        0; Elapsed time (ms): 3.5167
```

```
$ ./bin/main 10000000
N: 10000000; Paralled: 1; Product:        0; Elapsed time (ms): 8.3651
N: 10000000; Paralled: 0; Product:        0; Elapsed time (ms): 30.2174
```

Почти везде произошло переполнение переменной `prod`, но это нам не особо важно, кажется, интересует скорее время выполнения.
На малых `N` последовательный код работает быстрее (что логично, т.к. операции очень простые (сумма, `if`. умножение), так что проще быстрее посчитать всё напрямую, чем заниматься созданием потоков и управлением ими), но при увеличении `N` параллельный код начинает работать быстрее последовательного.
