# Лабораторная работа 4

## Задание 1

Модифицировать программу, составленную по **Заданию 1** в **Л.Р. №3**, используя синхронизацию вместо редукции. Измерять время работы программы для тех же значений
параметров, что были использованы при выполнении **Л.Р. №3**.

## Как запустить

```
make; \
./bin/main 100
```

тут 100 - длина массивов (`N`)

## Результат работы

```
$ ./bin/main 100
N: 100; Paralled: 1; Product:        0; Elapsed time (ms): 0.1505
N: 100; Paralled: 0; Product:        0; Elapsed time (ms): 0.0030
```

```
$ ./bin/main 1000
N: 1000; Paralled: 1; Product:        0; Elapsed time (ms): 0.1939
N: 1000; Paralled: 0; Product:        0; Elapsed time (ms): 0.0050
```

```
$ ./bin/main 10000
N: 10000; Paralled: 1; Product:        0; Elapsed time (ms): 0.4253
N: 10000; Paralled: 0; Product:        0; Elapsed time (ms): 0.0395
```

```
$ ./bin/main 100000
N: 100000; Paralled: 1; Product:        0; Elapsed time (ms): 2.8885
N: 100000; Paralled: 0; Product:        0; Elapsed time (ms): 0.3849

```

```
$ ./bin/main 1000000
N: 1000000; Paralled: 1; Product:        0; Elapsed time (ms): 28.3129
N: 1000000; Paralled: 0; Product:        0; Elapsed time (ms): 3.9030

```

```
$ ./bin/main 10000000
N: 10000000; Paralled: 1; Product:        0; Elapsed time (ms): 334.5214
N: 10000000; Paralled: 0; Product:        0; Elapsed time (ms): 39.0238
```

Почти везде произошло переполнение переменной `prod`, но это нам не особо важно.

Время исполнения последовательного кода такое же, как в **Л.Р. №3**.

При всех `N` последовательный код работает быстрее параллельного. Из-за применения директивы `omp critical` во время параллельного исполнения кода происходит большое количество блокировок, а уже вследствие этого работа ядер сводится по большей части к ожиданию.
